<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <%= wicked_pdf_stylesheet_link_tag    'application' %>
    <%= wicked_pdf_javascript_include_tag 'application'%>

  </head>
  <body>
    <div id="content">
      <%= yield %>
      <%= content_tag :div, class: "data", data: {temp: @chart_data} do %>
      <% end %>
    </div>
    <script type="text/javascript">

     var data = JSON.parse($('.data').attr('data-temp'));

     buildAll(data);

     // buildLdlCho(data);

     // buildHdlTri(data);


    function buildAll(data){
      var margin = {top: 30, right: 20, bottom: 70, left: 50},
          width = 768 - margin.left - margin.right,
          height = 500 - margin.top - margin.bottom;

      var parseDate = d3.time.format("%b %Y").parse;

      // Set the ranges
      var x = d3.time.scale().range([0, width]);
      var y = d3.scale.linear().range([height, 0]);

      // Define the axes
      var xAxis = d3.svg.axis().scale(x)
          .tickFormat(d3.time.format("%m/%y"))
          .orient("bottom");

      var yAxis = d3.svg.axis().scale(y)
        .ticks(data.entries.length/4)
        .orient("left");

      // Define the line
      var priceline = d3.svg.line()
          .x(function(d) { return x(d.date); })
          .y(function(d) { return y(d.value); });

      // Adds the svg canvas
      var svg = d3.select("#graph")
      .append("svg")
          .attr("class", "chart")
          .attr("width", 925)
          .attr("height", height + margin.top + margin.bottom)
          .append("g")
            .attr("transform",
                  "translate(" + margin.left + "," + margin.top + ")");


      data.entries.forEach(function(d) {
        d.date = parseDate(d.date);
        d.value = +d.value;
      });

      // Scale the range of the data
      var minDate = new Date(data.entries[0].date.getFullYear()-1, data.entries[0].date.getMonth()+1,data.entries[0].date.getDate());
      var maxDate = new Date(data.entries[data.entries.length - 1].date.getFullYear()+1, data.entries[data.entries.length - 1].date.getMonth()+1,data.entries[data.entries.length - 1].date.getDate());

      x.domain([minDate, maxDate]);
      y.domain([d3.min(data.entries, function(d) { return d.value; })-75, d3.max(data.entries, function(d) { return d.value; })+75]);

      // Nest the entries by symbol
      var dataNest = d3.nest()
          .key(function(d) {return d.symbol;})
          .entries(data.entries);

      var color = d3.scale.ordinal().range(['#111A33', '#001E93', '#4FCFEB', '#A725A7']);


      legendSpace = width/dataNest.length; // spacing for the legend

      var th =d3.scale.ordinal().range([130, 46, 150, 200]);
      var thd =d3.scale.ordinal().domain([130, 46, 150, 200]);



      // Loop through each symbol / key
      dataNest.forEach(function(d,i) {
          svg.append("clipPath")
                .attr("id", "clip-above")
              .append("rect")
                .attr("width", width)
                .attr("height", y(th(d.key)));

            svg.append("clipPath")
                .attr("id", "clip-below")
              .append("rect")
                .attr("y", y(th(d.key)))
                .attr("width", width)
                .attr("height", height - y(th(d.key)));

            var clip = ["below", "above"];

            clip.forEach(function(v,i){
              svg.append("path")
                .attr("class", function() { return 'tag'+d.key.replace(/\s+/g, '') + " line " + v; })
                .attr("clip-path", function() { return "url(#clip-" + v + ")"; })
                // .attr("id", 'tag'+d.key.replace(/\s+/g, ''))
                .attr("d", priceline(d.values))
                .style("stroke-dasharray", function(){
                    if(i === 0){
                      return ("0, 0");
                    }
                    else{
                      return ("0,0");
                    }
                })
                .style("stroke", function() { // Add the colours dynamically
                    return color(d.key);
                })
                .style("fill", 'none');
            });

          // Add the Legend
          svg.append("text")
              .attr("x", (legendSpace/2)+i*legendSpace)
              .attr("y", height + (margin.bottom/2)+ 5)
              .attr("class", "legend")
              .style("fill", function() {
                  return color(d.key);
              })
              .text(d.key);

      });

      // Add the X Axis
      svg.append("g")
          .attr("class", "x axis")
          .attr("transform", "translate(0," + height + ")")
          .call(xAxis);

      // Add the Y Axis
      svg.append("g")
          .attr("class", "y axis")
          .call(yAxis);

      // Add the dots
      svg.selectAll('.dots')
          .data(data.entries)
          .enter()
          .append("g")
          .attr("class", function(d, i){
            return 'dots tag'+ d.symbol.replace(/\s+/g, '')
          })
          .attr('clip-path', "url(#clip)")
          .append('circle')
          .attr("r", 5)
          .attr('fill', function(d,i){
            if(th(d.symbol) < d.value){
              return "#fff";
            }
            else{
              return d.color = color(d.symbol);
            }

          })
          .attr('stroke', function(d,i){
            return color(d.symbol);
          })
          .attr("transform", function(d) {
            return "translate("+x(d.date)+","+y(d.value)+")";
          });
      // Add the text
      svg.selectAll('.text-values')
          .data(data.entries)
          .enter()
          .append("text")
          .attr("id", function(d,i){
            return 'val'+d.symbol.replace(/\s+/g, '')+i;
          })
          .attr('class', function(d,i){
            return 'text-values tag'+d.symbol.replace(/\s+/g, '');
          })
          // .attr('class', 'text-values')
          .attr("transform", function(d) {
            if(d.symbol === 'HDL' || d.symbol === 'LDL'){
              return "translate("+(x(d.date)-7.5)+","+(y(d.value)+20)+")";
            }
            else{
              return "translate("+(x(d.date)-7.5)+","+(y(d.value)-10)+")";
            }
          })
          .text(function(d){
            return d.value;
          })
          .style("fill", function(d) { // Add the colours dynamically
              return color(d.symbol);
          });

          /*
          
          INTERVENTIONS

           */

          if(data.interventions.length>0){
            var parseInterventionDate = d3.time.format("%Y-%m-%d").parse;
            data.interventions.forEach(function(d) {
              d.start = parseInterventionDate(d.start);
              d.end = parseInterventionDate(d.end);
              d.title = d.title;
              d.description = d.description;
            });


          svg.selectAll('.chart')
            .data(data.interventions)
            .enter()
            .append('rect')
            .style("opacity", 0.1)
            .attr('width', function(d,i){
                return x(d.end)-x(d.start);
            })
            .attr('x', function(d) {
                return x(d.start);
              })
            .attr('y',75)
            .attr('height', function(d) {
              return height-75;
            })
            .attr("class", "interventions")
            .attr("fill", function(d){
                return color(x(d.end)-x(d.start));
            });

          svg.selectAll('.chart')
            .data(data.interventions)
            .enter()
            .append("text")
            .html(function(d){
              return d.title+" - "+d.description;
            })
            .style("opacity", 1)
            .attr('x', function(d) {
                return x(d.start)+5;
            })
            .attr('y', 60)
            .attr("class", "intervention-text")
            .attr('width', function(d,i){
                return x(d.end)-x(d.start);
            })
            .style('background-color', 'red')
            .attr("fill", "black");
    }

// // Adds the svg canvas
// var svg = d3.select("#graph")
//     .append("svg")
//     .attr("class", "chart")
//         .attr("width", 925)
//         .attr("height", height + margin.top + margin.bottom)
//         .append("g")
//           .attr("transform",
//                 "translate(" + margin.left + "," + margin.top + ")");

//     data.entries.forEach(function(d) {
//       d.date = parseDate(d.date);
//       d.value = +d.value;
//     });



//     // Scale the range of the data
//     x.domain(d3.extent(data.entries, function(d) { return d.date; }));
//     y.domain([0, d3.max(data.entries, function(d) { return d.value; })+75]);

//     // Nest the entries by symbol
//     var dataNest = d3.nest()
//         .key(function(d) {return d.symbol;})
//         .entries(data.entries);

//     // var color = d3.scale.category20();   // set the colour scale
//     var color = d3.scale.ordinal().range(['#111A33', '#001E93', '#4FCFEB', '#A725A7']);
//     legendSpace = width/dataNest.length; // spacing for the legend

//     // Loop through each symbol / key
//     dataNest.forEach(function(d,i) {

//         svg.append("path")
//             .attr("class", "line")
//             .attr("id", 'tag'+d.key.replace(/\s+/g, '')) // assign ID
//             .attr("d", priceline(d.values))
//             .style("stroke", function() { // Add the colours dynamically
//                 return d.color = color(d.key); })
//             .on("click", function(){
//               // Determine if current line is visible
//                 var active   = d.active ? false : true;
//                 newOpacity = active ? 0 : 1;
//                 // Hide or show the elements based on the ID
//                 d3.select("#tag"+d.key.replace(/\s+/g, ''))
//                     .transition().duration(100)
//                     .style("opacity", newOpacity);
//                 d3.selectAll(".tag"+d.key.replace(/\s+/g, ''))
//                     .transition().duration(100)
//                     .style("opacity", newOpacity);
//                 // Update whether or not the elements
//                 d.active = active;
//             });

//         // Add the Legend
//         svg.append("text")
//             .attr("x", width + margin.left + 50)  // space legend
//             .attr("y", 100 + i * (margin.bottom/2)+ 5)
//             .attr("class", "legend")    // style the legend
//             .style("fill", function() { // Add the colours dynamically
//                 return d.color = color(d.key); })
//             .on("click", function(){
//                 // Determine if current line is visible
//                 var active   = d.active ? false : true;
//                 newOpacity = active ? 0 : 1;
//                 // Hide or show the elements based on the ID
//                 d3.select("#tag"+d.key.replace(/\s+/g, ''))
//                     .transition().duration(100)
//                     .style("opacity", newOpacity);
//                 d3.selectAll(".tag"+d.key.replace(/\s+/g, ''))
//                     .transition().duration(100)
//                     .style("opacity", newOpacity);
//                 // Update whether or not the elements are active
//                 d.active = active;
//             })
//             .text(d.key);

//     });

//     // Add the X Axis
//     svg.append("g")
//         .attr("class", "x axis")
//         .attr("transform", "translate(0," + height + ")")
//         .call(xAxis);

//     // Add the Y Axis
//     svg.append("g")
//         .attr("class", "y axis")
//         .call(yAxis);

//     // Add the dots
//     svg.selectAll('.dots')
//         .data(data.entries)
//         .enter()
//         .append("g")
//         .attr("class", function(d, i){
//           return 'dots tag'+ d.symbol.replace(/\s+/g, '')
//         })
//         .attr('clip-path', "url(#clip)")
//         .append('circle')
//         .attr("r", 2.5)
//         .attr('fill', function(d,i){
//           return d.color = color(d.symbol);
//         })
//         .attr("transform", function(d) {
//           return "translate("+x(d.date)+","+y(d.value)+")";
//         });

//     // Add the text
//     svg.selectAll('.text-values')
//         .data(data.entries)
//         .enter()
//         .append("text")
//         .attr('class', 'text-values')
//         .attr("transform", function(d) {
//           if(d.symbol === 'HDL' || d.symbol === 'LDL'){
//             return "translate("+(x(d.date)-7.5)+","+(y(d.value)+20)+")";
//           }
//           else{
//             return "translate("+(x(d.date)-7.5)+","+(y(d.value)-10)+")";
//           }
//         })
//         .text(function(d){
//           return d.value;
//         })
//         .style("fill", function(d) { // Add the colours dynamically
//             return color(d.symbol);
//         });

//     if(data.interventions.length>0){
//       var parseInterventionDate = d3.time.format("%Y-%m-%d").parse;
//       data.interventions.forEach(function(d) {
//         d.start = parseInterventionDate(d.start);
//         d.end = parseInterventionDate(d.end);
//         d.title = d.title;
//         d.description = d.description;
//       });


//     svg.selectAll('.chart')
//       .data(data.interventions)
//       .enter()
//       .append('rect')
//       .style("opacity", 0.1)
//       .attr('width', function(d,i){
//         // console.log(x(d.end)-x(d.start));
//           return x(d.end)-x(d.start);
//       })
//       .attr('x', function(d) {
//           return x(d.start);
//         })
//       .attr('height', function(d) {
//         return height
//       })
//       .attr("class", "interventions")
//       .attr("fill", function(d){
//           return color(x(d.end)-x(d.start));
//       });

//     svg.selectAll('.chart')
//       .data(data.interventions)
//       .enter()
//       .append("text")
//       .text(function(d){
//         return d.title+" - "+d.description;
//       })
//       .style("opacity", 1)
//       .attr('x', function(d) {
//           return x(d.start)+25;
//         })
//       .attr('y', margin.top)
//       .attr("class", "intervention-text")
//       .attr('width', function(d,i){
//         // console.log(x(d.end)-x(d.start));
//           return x(d.end)-x(d.start);
//       })
//       .style('background-color', 'red')
//       .attr("fill", "black");
    }
    </script>
  </body>
</html>
